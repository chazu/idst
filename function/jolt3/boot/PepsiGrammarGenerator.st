"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"

{ import: GrammarParser }
PepsiGrammarGenerator : GrammarParser (name attribute attributes depth maxDepth)
PepsiGrammarGenerator start :inputStream
[
| _ok_ pos1 |
_ok_ := (((pos1 := inputStream position)
 and: [(self Header :inputStream)
 and: [((inputStream pushGroup: (TokenGroup new add: (((self Grammar :inputStream)) ifTrue: [result] ifFalse: [result]))) ifTrue: [(self Generate :inputStream)])]])
 or: [(inputStream position: pos1)]).
^_ok_
]
PepsiGrammarGenerator Header :inputStream
[
| _ok_ pos1 |
_ok_ := ([ '"THIS FILE WAS GENERATED AUTOMATICALLY -- DO NOT EDIT!"\n\n' put . 1] value).
^_ok_
]
PepsiGrammarGenerator Generate :inputStream
[
| i p v locals _ok_ pos1 pos2 pos3 pos4 pos5 pos6 pos7 pos8 pos9 |
_ok_ := ((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #grammar) ifTrue: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self Generate :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #declaration) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [([ ('{ import: ', p, ' }') putln.  ((name := i asString), ' : ', p, ' (') put . 1] value)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((pos5 := TokenGroup new)
 and: [[(((pos6 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])
 and: [([v asString put. 1] value)
 and: [(((pos7 := inputStream position)
 and: [(((pos8 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([' ' put. 1] value)]])
 or: [(inputStream position: pos8)])]) ifTrue: [(inputStream position: pos7). 1])]]])
 or: [(inputStream position: pos6)])] whileTrue: [(pos5 add: result)]. (result := pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')') putln.  optionTrace ifTrue: ['TraceIndent := [0]' putln] . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #definition) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])
 and: [([ maxDepth := depth := 0 . 1] value)
 and: [(((pos4 := inputStream position)
 and: [(self reserve :inputStream)]) ifTrue: [(inputStream position: pos4). 1])
 and: [(((result := [ IdentityDictionary new ] value) or: [1])
 and: [locals := result. 1])
 and: [(((pos4 := inputStream position)
 and: [((inputStream pushGroup: (TokenGroup new add: locals)) ifTrue: [(self collect :inputStream)])]) ifTrue: [(inputStream position: pos4). 1])
 and: [([ (attribute := p notEmpty) ifTrue:
								     [((attribute := name, '_', i), ' : Object (') put.
								      attributes := p.
								      p do: [:n | ' ' put.  n asString put].
								      ' )' putln.
								      (attribute, ' new') put.
								      p do: [:n | (' :_', n) put].
								      ' [self := super new' put.
								      p do: [:n | ('. ', n, ' := _', n) put].
								      ']' putln.
								      p do: [:n | (attribute, ' ', n, ' [^', n, ']') putln]].
								  (name, ' ', i, ' :inputStream\n[') putln.
								  p do: [:n | locals at: n put: true].
								  locals at: #_ok_ put: true.
								  optionMemo ifTrue: [locals at: #_memo_ put: true].
								  locals := locals keys.
								  maxDepth > 0 ifTrue: [1 to: maxDepth do: [:n | locals add: 'pos', n printString]].
								  locals notEmpty ifTrue: ['|' put.  locals do: [:n | (' ', n) put].  ' |' putln].
								  "p do: [:n | n asString put.  ' := inputStream next.' putln]."
								  optionTrace ifTrue: [('StdErr space: (TraceIndent := TraceIndent + 2); println: ''', i, '''.') putln].
								  optionMemo ifTrue: [('(_memo_ := self memoized: #',i,' :inputStream) ifTrue: [^_memo_ success ifTrue: [inputStream position: _memo_ next.  result := _memo_ result.  self]].\n_memo_ := inputStream position.') putln].
								  '_ok_ := ' put. . 1] value)
 and: [(self generate :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '.\n' put.
		  						  attribute ifTrue:
								     ['_ok_ ifTrue: [' put.
								      ('result := ', attribute, ' new') put.
								      attributes do: [:n | (' :', n) put].
								      '].' putln].
								  optionTrace ifTrue:
								     [('StdErr space: TraceIndent; print: ''',i,'''; nextPutAll: (_ok_ ifTrue: ['' ok''] ifFalse: ['' FAIL'']); cr.\nTraceIndent := TraceIndent - 2.\n') put].
								  optionMemo ifTrue: [('self memoize: #',i,' at: _memo_ success: _ok_ result: result :inputStream.') putln].
								  '^_ok_\n]' putln. . 1] value)]])
 or: [(inputStream position: pos1)])]]).
^_ok_
]
PepsiGrammarGenerator generate :inputStream
[
| id e v c a p i l s x _ok_ pos1 pos2 pos3 pos4 pos5 pos6 pos7 pos8 |
_ok_ := ((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #alternatives) ifTrue: [result := inputStream next. 1])
 and: [((((pos3 := inputStream position)
 and: [(((pos4 := inputStream position)
 and: [(((pos5 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6)] ifFalse: [1])]])
 or: [(inputStream position: pos5)])]) ifTrue: [(inputStream position: pos4). 1])
 and: [(self generate :inputStream)]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [([ '(' put . 1] value)
 and: [(((pos4 := inputStream position)
 and: [((pos5 := TokenGroup new)
 and: [[(((pos6 := inputStream position)
 and: [(self generate :inputStream)
 and: [(((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos7). 1])
 and: [(['\n or: [' put. 1] value)]]])
 or: [(inputStream position: pos6)])] whileTrue: [(pos5 add: result)]. (result := pos5)])]) ifTrue: [(inputStream position: pos4). 1])
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [([       ']' put. 1] value)]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])
 and: [([ ')' put . 1] value)]]]])
 or: [(inputStream position: pos3)])])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 and: [(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos4)] ifFalse: [1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ 'true' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 and: [((((pos3 := inputStream position)
 and: [(((pos4 := inputStream position)
 and: [(((pos5 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6)] ifFalse: [1])]])
 or: [(inputStream position: pos5)])]) ifTrue: [(inputStream position: pos4). 1])
 and: [(self generate :inputStream)]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [(((pos4 := inputStream position)
 and: [((pos5 := TokenGroup new)
 and: [[(((pos6 := inputStream position)
 and: [(['\n and: [' put. 1] value)
 and: [(self generate :inputStream)]])
 or: [(inputStream position: pos6)])] whileTrue: [(pos5 add: result)]. (result := pos5)])]) ifTrue: [(inputStream position: pos4). 1])
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [([        ']' put. 1] value)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])
 and: [([ ')\n or: [' put . 1] value)
 and: [(self restore :inputStream)
 and: [([ '])' put . 1] value)]]]]]]])
 or: [(inputStream position: pos3)])])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put . 1] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [' put . 1] value)
 and: [(self restore :inputStream)]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '] ifFalse: [1])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #store) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [id := result. 1])
 and: [([ ('(') put . 1] value)
 and: [(self generate :inputStream)]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('\n and: [', id, ' := result. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self save :inputStream)
 and: [([ '\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']) ifTrue: [result := (' put . 1] value)
 and: [(self position :inputStream)
 and: [([ ' text: inputStream position)])' put . 1] value)
 and: [(self release :inputStream)]]]]]]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroOne) ifTrue: [result := inputStream next. 1])
 and: [([ ('((') put . 1] value)
 and: [(self generate :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (') ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 and: [([ '(' put . 1] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [[' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ '] whileTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put . 1] value)
 and: [(self egroup :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [e := result. 1])
 and: [([ '(' put . 1] value)
 and: [(self bgroup :inputStream)
 and: [([ '\n and: [((' put . 1] value)
 and: [((inputStream pushGroup: (TokenGroup new add: e)) ifTrue: [(self generate :inputStream)])
 and: [([ ') ifTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ '. 1])\n and: [[' put . 1] value)
 and: [((inputStream pushGroup: (TokenGroup new add: e)) ifTrue: [(self generate :inputStream)])
 and: [([ '] whileTrue: [' put . 1] value)
 and: [(self append :inputStream)
 and: [([ ']. ' put . 1] value)
 and: [(self egroup :inputStream)]]]]]]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. 1]])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((inputStream peek == #dot) ifTrue: [result := inputStream next. 1])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(inputStream notAtEnd and: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #value) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((result := [', v, '] value) or: [1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #variable) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [v := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((result := ' , v,             ') or: [1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #character) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [c := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((result := ' , c printString, ') or: [1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #action) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [a := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('([', a, '. 1] value)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #predicate) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [p := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('([', p, '] value)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #group) ifTrue: [result := inputStream next. 1])
 and: [([ ('((result := TokenGroup new)') put . 1] value)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(self element :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([';' put. 1] value)]])
 or: [(inputStream position: pos7)])]) ifTrue: [(inputStream position: pos6). 1])]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unigroup) ifTrue: [result := inputStream next. 1])
 and: [([ ('(result := ((TokenGroup new)') put . 1] value)
 and: [(self element :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (') first)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #format) ifTrue: [result := inputStream next. 1])
 and: [([ '((result := TokenGroup new)' put . 1] value)
 and: [((pos4 := TokenGroup new)
 and: [[(self generate :inputStream)] whileTrue: [(pos4 add: result)]. (result := pos4)])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ' yourself)' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #formatChar) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [c := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ' add: '    put.  c print.         ';' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #formatVariable) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ' addAll: ' put.  i asString put.  ';' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #formatString) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ' addAll: ' put.  i asString put.  ' asString;' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [(((pos4 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos4)] ifFalse: [1])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('(self ', i, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #invoke) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [i := result. 1])
 and: [([ ('((inputStream pushGroup: (TokenGroup new') put . 1] value)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6). 1])
 and: [([ ' add: ' put . 1] value)
 and: [(self argument :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(((((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([';' put. 1] value)]])
 or: [(inputStream position: pos7)])) ifTrue: [result := TokenGroup with: result] ifFalse: [result := TokenGroup new])]) ifTrue: [(inputStream position: pos6). 1])]]]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')) ifTrue: [(self ', i, ' :inputStream)])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #literal) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [l := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ('((inputStream peek == ', l printString, ') ifTrue: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #string) ifTrue: [result := inputStream next. 1])
 and: [((((pos3 := inputStream position)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos5 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6)] ifFalse: [1])]])
 or: [(inputStream position: pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])
 and: [([ ('((inputStream peek == ', s printString, ') ifTrue: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])
 and: [([ ('(self string: ', s printStringEscaped, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos3)])])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [((inputStream peek == #class) ifTrue: [result := inputStream next. 1])
 and: [((((pos3 := inputStream position)
 and: [(((pos4 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos5 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])
 and: [(((pos6 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])]) ifTrue: [(inputStream position: pos6)] ifFalse: [1])]])
 or: [(inputStream position: pos5)])]]) ifTrue: [(result := (inputStream := pos4) next)] ifFalse: [(inputStream := pos4). nil])
 and: [([ ('((inputStream peek == ', s printString, ') ifTrue: [result := inputStream next. 1])') put . 1] value)]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])
 and: [([ ('(self class: ', s unescaped asCharacterClass printString, ' :inputStream)') put . 1] value)]])
 or: [(inputStream position: pos3)])])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])
 and: [([ '((' put . 1] value)
 and: [(self bstream :inputStream)
 and: [([ '\n and: [(inputStream := self beginStructure: inputStream)\n and: [' put . 1] value)
 and: [(self generate :inputStream)
 and: [([ ']]) ifTrue: [' put . 1] value)
 and: [(self nstream :inputStream)
 and: [([ '] ifFalse: [' put . 1] value)
 and: [(self estream :inputStream)]]]]]]]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ '. nil])' put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])
 and: [([ self error: 'unknown expression: ', x printString . 1] value)]])
 or: [(inputStream position: pos1)])]]]]]]]]]]]]]]]]]]]]]]]]]]]]).
^_ok_
]
PepsiGrammarGenerator argument :inputStream
[
| x _ok_ pos1 pos2 pos3 |
_ok_ := ((((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #argvar) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x asString put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #arglit) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x printString put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #argsym) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ x printString put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #result) ifTrue: [result := inputStream next. 1])
 and: [(['((' put. 1] value)
 and: [(self generate :inputStream)]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ ') ifTrue: [result] ifFalse: [result])' put . 1] value)]])
 or: [(inputStream position: pos1)])]]]).
^_ok_
]
PepsiGrammarGenerator element :inputStream
[
| s x _ok_ pos1 pos2 pos3 pos4 pos5 pos6 pos7 |
_ok_ := ((((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #subgroup) ifTrue: [result := inputStream next. 1])
 and: [([ (' add: (TokenGroup new') put . 1] value)
 and: [((pos4 := TokenGroup new)
 and: [[(((pos5 := inputStream position)
 and: [(self element :inputStream)
 and: [(((pos6 := inputStream position)
 and: [(((pos7 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [([';' put. 1] value)]])
 or: [(inputStream position: pos7)])]) ifTrue: [(inputStream position: pos6). 1])]])
 or: [(inputStream position: pos5)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (')') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #symbol) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' add: ', s printString) put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unquote) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' add: ', s) put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unquoteSplicing) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' concat: ', s) put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unquoteString) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' add: (', s, ' asString)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unquoteSymbol) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' add: (', s, ' asSymbol)') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [(((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos3 := inputStream position)
 and: [((inputStream peek == #unquoteNumber) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [s := result. 1])]])
 or: [(inputStream position: pos3)])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 and: [([ (' add: (Integer fromString: ', s, ')') put . 1] value)]])
 or: [(inputStream position: pos1)])
 or: [(((pos1 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [x := result. 1])
 and: [([ self error: 'malformed group element: ', x printString . 1] value)]])
 or: [(inputStream position: pos1)])]]]]]]]).
^_ok_
]
PepsiGrammarGenerator collect :inputStream
[
| locals n _ok_ pos1 pos2 pos3 pos4 pos5 |
_ok_ := (((pos1 := inputStream position)
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [locals := result. 1])
 and: [((((pos2 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [((((pos3 := inputStream position)
 and: [((inputStream peek == #store) ifTrue: [result := inputStream next. 1])
 and: [((inputStream notAtEnd and: [result := inputStream next. 1])
 and: [n := result. 1])
 and: [([ locals at: n put: true . 1] value)
 and: [((inputStream pushGroup: (TokenGroup new add: locals)) ifTrue: [(self collect :inputStream)])]]]])
 or: [(inputStream position: pos3)])
 or: [(((pos3 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [((pos4 := TokenGroup new)
 and: [[((inputStream pushGroup: (TokenGroup new add: locals)) ifTrue: [(self collect :inputStream)])] whileTrue: [(pos4 add: result)]. (result := pos4)])]])
 or: [(inputStream position: pos3)])])]]) ifTrue: [(result := (inputStream := pos2) next)] ifFalse: [(inputStream := pos2). nil])
 or: [(inputStream notAtEnd and: [result := inputStream next. 1])])]])
 or: [(inputStream position: pos1)]).
^_ok_
]
PepsiGrammarGenerator reserve :inputStream
[
| _ok_ pos1 pos2 pos3 pos4 |
_ok_ := ((((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(((inputStream peek == #sequence) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #and) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #not) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #text) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #zeroMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #oneMany) ifTrue: [result := inputStream next. 1])
 or: [((inputStream peek == #structure) ifTrue: [result := inputStream next. 1])]]]]]])
 and: [([ maxDepth := maxDepth max: (depth := depth + 1) . 1] value)
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])
 and: [([ depth := depth - 1 . 1] value)]]]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(((pos1 := inputStream)
 and: [(inputStream := self beginStructure: inputStream)
 and: [(((pos2 := inputStream position)
 and: [(inputStream notAtEnd and: [result := inputStream next. 1])
 and: [((pos3 := TokenGroup new)
 and: [[(self reserve :inputStream)] whileTrue: [(pos3 add: result)]. (result := pos3)])]])
 or: [(inputStream position: pos2)])]]) ifTrue: [(result := (inputStream := pos1) next)] ifFalse: [(inputStream := pos1). nil])
 or: [(inputStream notAtEnd and: [result := inputStream next. 1])]]).
^_ok_
]
PepsiGrammarGenerator save :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(pos', (depth := depth + 1) printString, ' := inputStream position)') put . 1] value).
^_ok_
]
PepsiGrammarGenerator position :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('pos', depth printString) put . 1] value).
^_ok_
]
PepsiGrammarGenerator backup :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(inputStream position: pos', depth printString, ')') put . 1] value).
^_ok_
]
PepsiGrammarGenerator restore :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(inputStream position: pos', depth printString, ')') put.  depth := depth - 1 . 1] value).
^_ok_
]
PepsiGrammarGenerator release :inputStream
[
| _ok_ pos1 |
_ok_ := ([ depth := depth - 1 . 1] value).
^_ok_
]
PepsiGrammarGenerator bgroup :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(pos', (depth := depth + 1) printString, ' := TokenGroup new)') put . 1] value).
^_ok_
]
PepsiGrammarGenerator append :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(pos', depth printString, ' add: result)') put . 1] value).
^_ok_
]
PepsiGrammarGenerator egroup :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(result := pos', depth printString, ')') put.  depth := depth - 1 . 1] value).
^_ok_
]
PepsiGrammarGenerator bstream :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(pos', (depth := depth + 1) printString, ' := inputStream)') put . 1] value).
^_ok_
]
PepsiGrammarGenerator nstream :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(result := (inputStream := pos', depth printString, ') next)') put . 1] value).
^_ok_
]
PepsiGrammarGenerator estream :inputStream
[
| _ok_ pos1 |
_ok_ := ([ ('(inputStream := pos', depth printString, ')') put.  depth := depth - 1 . 1] value).
^_ok_
]
